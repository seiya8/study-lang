# memo

## 3.5 fmtパッケージ

- `println()`, `print()`は標準エラー出力。`fmt.Println()`や`fmt.Printf()`は標準出力。
- `fmt.Printf()`の使い方。
  - `%d`: 10進数, `%b`: 2進数, `%x`: 16進数, `%s`: 文字列
  - `%v`はどんな型でもOK。配列など。

## 3.6 変数

- 値型、参照型（スライス、マップ、チャネル）、ポインタ型の3種類。
- パッケージ変数とローカル変数。
- 定義したが参照されない変数があるとコンパイルエラー。
- 明示的な定義をして代入
  ```go
  var n int
  var x, y, z int
  var (
    i, j int
    name string
  )
  i, j = 1, 2
  ```
- 暗黙的な定義（型推論）
  ```go
  i := 1 // int
  f := 3.14 // float64
  i = 2 // これはOKだが、
  i := 2 // 再定義は無理
  ```
- 複数変数の暗黙的な定義
  ```go
  var (
    n = 1
    s = "string"
  )
  ```
  これは、`n := 1`と`s := "string"`を並べるより見やすいため好まれる。

### 3.8 配列

- 定義
  ```go
  a := [3]int{} // [0,0,0]
  a := [3]int{1} // [1,0,0]
  a := [...]int{1,2,3} // 初期値の数が要素数となる
  ```
- Goの配列は固定長。Sliceが可変長配列にあたる。

### 3.9 interface{}

- すべての型と互換だが、演算はできない。初期値はnil。
  ```go
  var x interface{}
  fmt.Printf("%#v", x) // nil
  x = 1
  x = 3.14
  ```

### 3.10 演算子
- `X & Y`: 論理積AND
- `X | Y`: 論理和OR
- `X ^ Y`: 排他的論理和XOR
- `X &^ Y`: ビットクリア X AND (NOT Y)
  - `X &^ X`は常に0。
- `X << n`: 左シフト, `X >> n`: 右シフト

### 3.11 関数
